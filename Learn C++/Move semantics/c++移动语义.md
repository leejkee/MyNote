## 移动语义、左值与右值

### 1. 左值（lvalue）

* **定义**：有**内存地址**、**具名**、**可寻址**的表达式。
* **特性**：可以取地址 `&`。
* **示例**：
    ```cpp
    int x = 10;     // x 是左值
    int& ref = x;   // ref 是左值引用，绑定到左值 x
    ```

### 2. 右值（rvalue）

* **定义**：**临时**的、**不具名**的表达式。通常在表达式结束后生命周期也结束。
* **特性**：**不可取地址** `&`。
* **示例**：
    ```cpp
    int result = 1 + 2; // (1 + 2) 的结果是右值
    void foo(int a);
    foo(10);            // 10 是右值
    std::string s1 = "hello";
    std::string s2 = s1 + " world"; // (s1 + " world") 的结果是右值
    ```

### 3. 右值引用（rvalue reference `&&`）

* **定义**：C++11 引入，**只能绑定到右值**的引用。
* **作用**：是实现**移动语义**的关键。
* **示例**：
    ```cpp
    std::string&& rref = std::string("temporary"); // rref 绑定到右值
    ```

### 4. 移动语义（Move Semantics）

* **核心思想**：避免不必要的深拷贝。当源对象是**右值**（即将销毁或不再使用）时，**直接“窃取”其资源**（如堆内存指针），而不是复制数据。
* **实现方式**：通过定义类的**移动构造函数** (`Class(Class&& other)`) 和**移动赋值运算符** (`Class& operator=(Class&& other)`)。
* **好处**：
    * **性能提升**：对于管理动态资源（如 `std::string`, `std::vector`）的类，移动操作通常比拷贝操作**快得多**。
    * **资源转移**：实现资源的**所有权转移**，而非复制。

### 5. `std::move()`

* **作用**：强制将一个**左值**“转换”为**右值引用**。
* **注意**：`std::move()` **本身不执行移动操作**，它只是一个类型转换（`static_cast<T&&>`）。真正的移动操作发生在调用接收右值引用的函数（如移动构造/赋值）时。
* **使用场景**：当你明确知道某个左值在转换后将不再使用时，可以使用 `std::move()` 来允许它被“移动”而非“拷贝”。
* **示例**：
    ```cpp
    std::vector<int> v1 = {1, 2, 3};
    std::vector<int> v2 = std::move(v1); // v1 的资源被“移动”到 v2，v1 变为有效但未指定状态
    // 此时不应再使用 v1，因为它可能为空或处于其他不确定状态
    ```